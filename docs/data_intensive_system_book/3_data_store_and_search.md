# 数据存储与检索

> 本节主要探讨两种存储引擎家族：
>
> - 日志结构的存储引擎，如 LSM；
> - 面向页的存储引擎，如 B-tree；

作为应用系统开发人员，为什么需要关注数据库内部的存储和检索呢？

- 不会从头实现存储引擎，而是从现有的存储引擎中选择；
- 为了特定的工作负载而对数据库调优时，需要对存储引擎的底层机制有了解；



## 数据库核心：数据结构

最简单的数据库，由两个 Bash 函数实现：

- 由纯文本格式进行存储，key 和 value 由 逗号 分隔；

```bash
# !/bin/bash
# 将文件存储为 db_func.sh

db_set() {
	echo "$1,$2" >> database
}

db_get() {
	grep "$1," database | sed "s/^$1,//" | tail -n 1
}
```

使用示例：多次设置同样的key，旧版本的值不会被覆盖，获取时返回最新的值

```shell
$ source db_func.sh
$ db_set 123 '{"name:" : "xliu"}'
$ db_set 456 '{"name": "book"}'
$ db_get 123
{"name:" : "xliu"}
```



> 日志：仅支持追加式更新的数据文件，可以是文本格式或者二进制格式。

性能分析：

- `db_set`追加到文件，性能很好（很难超过简单的追加文件的性能）；
- `db_get`的性能跟记录数呈线性关系，**复杂度`O(N)`**；



如何**高效查找**数据库中特定键的值？新的数据结构：**索引**

- 保留额外的元数据，作为路标，定位目标数据；
- **适当的索引可以加速读取查询，但每个索引都会减慢写入速度**；
- 应用开发人员或者DB管理员，根据查询模式，手动建立索引；



### 哈希索引

> 针对 key- value 类型的索引，单点查询。

通过 hashmap ，将每个**键映射到文件中的特定的字节偏移量**：

- Bitcask 的核心做法$^{[1]}$，其是 Riak 中默认的存储引擎；

- **查找只需要一次磁盘寻址**，可将数据加载到内存，如果数据在文件系统缓存，则不需要磁盘I/O；

<font color="red">缺图</font>

适合于**每个键的值频繁更新**的场景，但 key 的数量不多，内存可以放下；

- 如 key是猫的视频URL，value 是它播放次数（更新时，先从磁盘获取数据，再 +1 后写盘）；

如上所述，只追加到一个文件，如何避免最终用户**用尽磁盘空间**？

- **一个文件不能执行压缩，将其旧的数据删除，节省磁盘空间**；
- 将日志文件分解成一定大小的段，文件达到一定大小是关闭，后续写入到新的文件中；
- 对于关闭的段文件，执行**压缩**，丢弃重复的键，只保留最新的数据；
- 段压缩后文件可能很小，可以将多个**段合并**成一个大的段；
- 压缩和合并后台异步执行：
  - 运行时，读取采用旧的段文件，写入到新的段文件；
  - 运行结束后，读写都采用新的段文件；

<font color="red">缺图</font>

**每个段都有自己的内存 hashmap**，将键映射到文件偏移量：

- 查找时，先查找最新的段的 hashmap，不存在则查找第二最新的段，以此类推（段的数量不能多）；



实现落地过程的其它细节：

- **文件格式**：CSV 不是最佳格式，更快更简单的是二进制格式：长度+数据
- **删除记录**：墓碑标记，认为某个键被删除；
- **崩溃恢复**：内存 hashmap 的重新构建，可以扫描段文件从头构建，或者保存每个段的 hashmap 的快照；
  - 快照是针对不再写入的段，如果正在写入的段，是否重头构建（保证一致性，每次更新hashmap，都保存快照则性能太慢）
- **部分写入**：数据库随时会崩溃，如将记录追加到日志过程中。Bitcask 文件包括校验值，可以发现损坏部分并丢弃；
- **并发控制**：通常采用一写多读的形式；



## 参考文献

[1]. 

