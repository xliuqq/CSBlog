# Network

## 查看可用的端口号范围

```shell
$ cat /proc/sys/net/ipv4/ip_local_port_range
```

## 查看带宽大小

```shell
$ etchtool em1
Settings for em1:
	Supported ports: [ FIBRE ]
	# 支持 1Gbps/10GB 全双工以太网连接
	Supported link modes:   1000baseT/Full 
	                        10000baseT/Full 
	Supported pause frame use: Symmetric Receive-only
	# 接口支持自动协商功能，用于确定最佳的连接速度和双工模式。
	Supports auto-negotiation: Yes
	Supported FEC modes: Not reported
	Advertised link modes:  1000baseT/Full 
	                        10000baseT/Full 
	Advertised pause frame use: Symmetric
	Advertised auto-negotiation: Yes
	Advertised FEC modes: Not reported
	# 当前接口的运行速度是 10Gbps
	Speed: 10000Mb/s
	Duplex: Full
	# 直接连接的铜缆
	Port: Direct Attach Copper
	PHYAD: 1
	Transceiver: internal
	Auto-negotiation: on
	Supports Wake-on: g
	Wake-on: d
	Current message level: 0x00000000 (0)
	# 接口与网络设备之间的物理连接是活动		       
	Link detected: yes
```

## 查看网桥和端口连接信息

`brctl show`

## netstat

格式：

```shell
$ netstat -a -p -n
```

- `-a (all)`显示所有选项，默认不显示LISTEN相关
- `-n` 拒绝显示别名，能显示数字的全部转化成数字。
- `-p` 显示建立相关链接的程序名
- `-t (tcp)`仅显示tcp相关选项
- `-u (udp)`仅显示udp相关选项
- `-l `仅列出有在 Listen (监听) 的服務状态
- `-r` 显示路由信息，路由表
- `-e` 显示扩展信息，例如uid等
- `-s` 按各个协议进行统计
- `-c` 每隔一个固定时间，执行该netstat命令。

netstat结果信息分两类

- Active Internet connections，有源**TCP连接**，

  ```
  Proto Recv-Q Send-Q LocalAddress ForeignAddress State
  tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED
  tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED
  tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED
  tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED
  tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE
  ```

- Active Unix domain sockets，有源**Unix域套接口**，**RefCnt表示连接到本套接口上的进程号**

  ```
  Proto RefCnt Flags Type State I-Node Path
  unix 1 [ ] STREAM CONNECTED 16178 @000000dd
  unix 1 [ ] STREAM CONNECTED 16176 @000000dc
  unix 9 [ ] DGRAM 5292 /dev/log
  unix 1 [ ] STREAM CONNECTED 16182 @000000df
  ```



## 自签名证书

创建**自签名证书**（Generated By ChatGpt）

```shell
# 生成私钥
openssl genrsa -out mykey.key 2048
# 创建证书签名请求（CSR）
openssl req -new -key mykey.key -out mycsr.csr -subj "/C=CN/ST=GuangDong/L=ShenZhen/O=Huawei/OU=CBC/CN=172.16.1.129"
# 自签名证书
openssl x509 -req -days 365 -in mycsr.csr -signkey mykey.key -out mycert.crt
# 可选（将证书和私钥转换为其他格式），如PKCS#12（.pfx或.p12）或Java KeyStore（.jks）
openssl pkcs12 -export -out mycert.pfx -inkey mykey.key -in mycert.crt
```



## 防火墙

### 服务操作

```shell
# 查看状态
systemctl status firewalld

firewall-cmd --state

# 开启
systemctl start firewalld
# 重启
systemctl restart firewalld
# 关闭
systemctl stop firewalld
```

### 查看防火墙规则

```bash
firewall-cmd --list-all 
```

### 查询、开放、关闭端口

参数解释

- `firwall-cmd`：是Linux提供的操作firewall的一个工具；
- `--permanent`：表示设置为持久；
- `--add-port`：标识添加的端口；

```bash
# 查询端口是否开放
firewall-cmd --query-port=8080/tcp
# 开放80端口
firewall-cmd --permanent --add-port=80/tcp
# 移除端口
firewall-cmd --permanent --remove-port=80/tcp
#重启防火墙(修改配置后要重启防火墙) 
firewall-cmd --reload
```



## 浮动 IP 创建

例如：两个机器 ip 地址为`192.168.2.5/6`；要设置的浮动 ip 为`192.168.2.10`

- 创建浮动ip：

  ```shell
  ifconfig eth0:1 192.168.2.10 netmask 255.255.255.0 up   # broadcast 192.168.2.255
  ```

- 将浮动 ip 写入本地开机启动，确保机器重启仍然生效

  ```shell
  echo ifconfig eth0:1 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 >> /etc/rc.local
  ```


- 停止浮动IP

  ```shell
  ifconfig eth0:1 down
  ```

使用 keepalived 的时候主机挂了，备机显示绑定了VIP。但是此时实际还是不能访问。其实就是网关的arp缓存没有刷新。

在服务器上执行一下就行了

```shell
arping -I eth0 -c 5 -s $VIP $GATEWAY
# intf=${1/:*/}  #`/usr/bin/awk '/default/ {print $2}' /etc/sysconfig/network/routes`
/sbin/arping -b -I "$intf" -s "$2" "$route" -c 4                 

## iptable

### 用法

```shell
$ iptables -t 表名 <-A/I/D/R> 规则链名 [规则号] <-i/o 网卡名> -p 协议名 <-s 源IP/源子网> --sport 源端口 <-d 目标IP/目标子网> --dport 目标端口 -j 动作
```

选项参数

- `-t<表>`：指定要操纵的表；
- `-A`：向规则链中添加条目；
- `-D`：从规则链中删除条目；
- `-I`：向规则链中插入条目；
- `-R`：替换规则链中的条目；
- `-L`：显示规则链中已有的条目；
- `-F`：清除规则链中已有的条目；
- `-Z`：清空规则链中的数据包计算器和字节计数器；
- `-N`：创建新的用户自定义规则链；
- `-P`：定义规则链中的默认目标；
- `-p`：指定要匹配的数据包协议类型；
- `-s`：指定要匹配的数据包源 ip 地址；
- `-d`：指定要匹配的数据包目标 ip 地址；
- `--sport num` 匹配来源端口号；
- `--dport num` 匹配目标端口号；
- `-j <动作>`：指定目标（jump target）或动作（action）；
- `-i <网络接口>`：指定数据包进入本机的网络接口，eth0；
- `-o <网络接口>`：指定数据包要离开本机所使用的网络接口。

表名包括：

- **raw**：高级功能，如：网址过滤。
- **mangle**：数据包修改（QOS），用于实现服务质量。
- **net**：地址转换，用于网关路由器。
- **filter**：包过滤，用于防火墙规则。（default）

规则链名包括：

- **INPUT链**：处理输入数据包。
- **OUTPUT链**：处理输出数据包。
- **FORWARD链**：处理转发数据包。
- **PREROUTING链**：用于目标地址转换（DNAT）。
- **POSTOUTING链**：用于源地址转换（SNAT）。

动作包括：

- **ACCEPT**：接收数据包。
- **DROP**：丢弃数据包。
- **REDIRECT**：重定向、映射、透明代理。
- **SNAT**：源地址转换。
- **DNAT**：目标地址转换。
- **MASQUERADE**：IP伪装（NAT），用于ADSL。
- **LOG**：日志记录。

### 示例

```shell
# 将所有iptables以序号标记显示
iptables -L -n --line-number

# 要删除INPUT里序号为8的规则
iptables -D INPUT 8

# 设置默认链为Accept，然后设置白名单（放通的IP），最后一条拒绝所有的请求
iptables -P INPUT ACCEPT
iptables -I INPUT -s 192.144.1.5 -p tcp --dport 7089 -j ACCEPT
iptables -A INPUT -j REJECT
```

## IP命令

### link 

```shell
# 启动回环设备
$ ip link set dev lo up
```

### netns

```shell
# 创建network namespace
$ ip netns add nstest

# 列出存在的network namespace
$ ip netns list

# 删除network namespace
$ ip netns delete nstest

# 在network namespace中执行命令，形式 ip netns exec <network namespace> <command>
$ ip netns exec nstest ip addr
```

### 示例

新建network namespace，创建veth-pair，分配IP，并与主机互通。

```shell
# 创建 nstest network namespace
$ ip netns add nstest

# 创建network namespace时，默认创建一个回环设备（loopback interface : lo），默认不启动
# 启动 nstest 的 lo
$ ip netns exec nstest ip link set dev lo up

# 主机上创建veth-pair两张虚拟网卡 veth-a 和 veth-b
$ ip link add veth-a type veth peer name veth-b

# 将veth-b设备添加到nstest，veth-a则留在主机
$ ip link set veth-b netns nstest

# 查看nstest应该具备lo和veth-b两张网卡
$ ip netns exec nstest ip link

# 为主机veth-a网卡分配IP并启动网卡
$ ip addr add 10.0.0.1/24 dev veth-a
$ ip link set dev veth-a up

# 为nstest的veth-b网卡分配IP并启动网卡
$ ip netns exec nstest ip addr add 10.0.0.2/24 dev veth-b
$ ip netns exec nstest ip link set dev veth-b up

# 为网卡配置好IP后，在各自的network namespace中会生成路由，查看
# 主机，表明目的地址10.0.0.0/24的IP包从veth-a网卡发出
$ ip route
10.0.0.0/24 dev veth-a proto kernel scope link src 10.0.0.1 

# nstest，表明目的地址10.0.0.0/24的IP包从veth-b网卡发出
$ ip netns exec nstest ip route
10.0.0.0/24 dev veth-b proto kernel scope link src 10.0.0.2

# 主机veth-a网卡ping nstest的veth-b网卡
$ ping 10.0.0.2

# nstest的veth-b网卡ping主机veth-a网卡
$ ip netns exec nstest ping 10.0.0.1
```

## bridge

上面的示例是通过 route 进行通信，本例是通过网桥对 veth pair 通信：

```shell
# 创建 veth pair
$ ip link add veth1 type veth peer name veth2
$ ip link set dev veth1 up
$ ip link set dev veth2 up

# 创建网桥br1
$ ip link add br0 type bridge

# 将 veth 加入 br0
$ ip link set veth1 master br0
$ ip link set veth2 master br0

# 网桥的地址，和 veth2 的地址
$ ip addr add 10.0.0.1/24 dev br0
$ ip addr add 10.0.0.2/24 dev veth2

# 查看所有的网桥以及对应的网卡信息
$ ip link show type bridge
$ bridge link

# 从网桥br1中删除eth0
$ ip link set dev eth0 nomaster

# 删除网桥br1
$ ip link del br1
```



## [pipework(Linux Container)](https://github.com/jpetazzo/pipework)

> Software-Defined Networking tools for LXC (LinuX Containers)



## TCP Dump

```shell
tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]
        [ -s snaplen ] [ -w file ] [ expression ]
```

**抓包选项**

-c：指定要抓取的包数量。

**-i interface**：指定tcpdump需要监听的接口。默认会抓取第一个网络接口。

-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。

**-nn**：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。

**-P**：指定要抓取的包是流入还是流出的包。可以给定的值为"in"、"out"和"inout"，默认为"inout"。

**-s len**：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断，输出行中会出现"[|proto]"的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。

**输出选项**

-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。

-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。

-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。

-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。

-v：当分析和打印的时候，产生详细的输出。

-vv：产生比-v更详细的输出。

-vvv：产生比-vv更详细的输出。

**功能性选项**

-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于"-i"后。

-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。

**-w**：将抓包数据输出到文件中而不是标准输出。可以同时配合"-G time"选项使得输出文件每time秒就自动切换到另一个文件。可通过"-r"选项载入这些文件以进行分析和打印。

**-r**：从给定的数据包文件中读取数据。使用"-"表示从标准输入中读取。